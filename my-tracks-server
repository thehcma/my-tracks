#!/usr/bin/env bash
#
# Start the Django development server with embedded MQTT broker
#
# Usage:
#   ./my-tracks-server [OPTIONS]
#
# Options:
#   --http-port PORT          Set HTTP server port (default: 8080, 0 = OS allocates, -1 = disabled)
#   --mqtt-port PORT     Set MQTT broker port (default: 1883, 0 = OS allocates, -1 = disabled)
#   --log-level LEVEL    Set Django log level (trace, debug, info, warning, error, critical)
#                        Default: warning (info when using --console)
#   --console            Output logs to console in addition to file (dual logging)
#   -h, --help           Show this help message
#
# Examples:
#   ./my-tracks-server                    # Start with default (port 8080, MQTT 1883)
#   ./my-tracks-server --http-port 18080       # Start on port 18080 for testing
#   ./my-tracks-server --mqtt-port -1     # Disable MQTT broker
#   ./my-tracks-server --mqtt-port 0      # MQTT broker on OS-allocated port
#   ./my-tracks-server --log-level debug  # Debug level, logs to file
#   ./my-tracks-server --console          # Info level (default for console), logs to BOTH console AND file
#   ./my-tracks-server --http-port 18080 --log-level debug --console  # Testing port, debug level, dual logging

set -e

# Server process PID (set when daphne starts)
server_pid=""
cleanup_done=false

# Graceful process termination: SIGTERM first, wait, then SIGKILL
# Usage: graceful_kill PID [WAIT_SECONDS]
graceful_kill() {
    local pid=$1
    local wait_seconds=${2:-3}
    
    if ! kill -0 "$pid" 2>/dev/null; then
        return 0  # Process already dead
    fi
    
    # Send SIGTERM first
    kill -TERM "$pid" 2>/dev/null || true
    
    # Wait for process to terminate
    local elapsed=0
    while [ $elapsed -lt $((wait_seconds * 2)) ]; do
        if ! kill -0 "$pid" 2>/dev/null; then
            return 0  # Process terminated gracefully
        fi
        sleep 0.5
        elapsed=$((elapsed + 1))
    done
    
    # Force kill if still running
    if kill -0 "$pid" 2>/dev/null; then
        kill -KILL "$pid" 2>/dev/null || true
        sleep 0.5
    fi
}

# Cleanup function to stop the server
cleanup() {
    # Prevent duplicate cleanup
    if [ "$cleanup_done" = true ]; then
        return
    fi
    cleanup_done=true
    
    echo ""
    if [ -n "$server_pid" ] && kill -0 "$server_pid" 2>/dev/null; then
        graceful_kill "$server_pid" 5
    fi
    # Also check for any orphaned processes on the HTTP port
    if [ "$http_port" -ge 0 ]; then
        remaining=$(lsof -ti tcp:"$http_port" 2>/dev/null || true)
        if [ -n "$remaining" ]; then
            echo "   Cleaning up orphaned HTTP processes on port $http_port..."
            for pid in $remaining; do
                graceful_kill "$pid" 2
            done
        fi
    fi
    # Also check for any orphaned processes on the MQTT port
    if [ "$mqtt_port" -ge 0 ]; then
        remaining=$(lsof -ti tcp:"$mqtt_port" 2>/dev/null || true)
        if [ -n "$remaining" ]; then
            echo "   Cleaning up orphaned MQTT processes on port $mqtt_port..."
            for pid in $remaining; do
                graceful_kill "$pid" 2
            done
        fi
    fi
    # Clean up runtime config file
    rm -f "config/.runtime-config.json"
    echo "ðŸ‘‹ Server stopped"
    exit 0
}

# Trap CTRL-C and TERM to exit cleanly
trap cleanup INT TERM EXIT

# Default values
http_port=8080
mqtt_port=1883
log_level="WARNING"
log_to_console=false

# Parse command line arguments
log_level_explicitly_set=false
while [[ $# -gt 0 ]]; do
    case $1 in
        --http-port)
            http_port="$2"
            shift 2
            ;;
        --mqtt-port)
            mqtt_port="$2"
            shift 2
            ;;
        --log-level)
            log_level=$(echo "$2" | tr '[:lower:]' '[:upper:]')
            log_level_explicitly_set=true
            shift 2
            ;;
        --console)
            log_to_console=true
            shift
            ;;
        -h|--help)
            sed -n '2,/^$/p' "$0" | sed 's/^# \?//'
            exit 0
            ;;
        *)
            echo "Error: Unknown option: $1"
            echo "Run './my-tracks-server --help' for usage information"
            exit 1
            ;;
    esac
done

# If --console is used and log level wasn't explicitly set, default to INFO
if [ "$log_to_console" = true ] && [ "$log_level_explicitly_set" = false ]; then
    log_level="INFO"
fi

# Validate port (0 = OS allocates, negative = disabled)
if ! [[ "$http_port" =~ ^-?[0-9]+$ ]] || [ "$http_port" -gt 65535 ]; then
    echo "Error: Invalid port number: $http_port"
    echo "Port must be a number between -1 and 65535 (0 = OS allocates, negative = disabled)"
    exit 1
fi

# Validate MQTT port (0 = OS allocates, negative = disabled)
if ! [[ "$mqtt_port" =~ ^-?[0-9]+$ ]] || [ "$mqtt_port" -gt 65535 ]; then
    echo "Error: Invalid MQTT port number: $mqtt_port"
    echo "Port must be a number between -1 and 65535 (0 = OS allocates, negative = disabled)"
    exit 1
fi

# Validate log level
case $log_level in
    TRACE|DEBUG|INFO|WARNING|ERROR|CRITICAL)
        ;;
    *)
        echo "Error: Invalid log level: $log_level"
        echo "Valid levels: trace, debug, info, warning, error, critical"
        exit 1
        ;;
esac

# Get the directory where this script is located
script_dir="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
cd "$script_dir"

# Check if server is already running on this port
existing_pids=$(lsof -ti tcp:"$http_port" 2>/dev/null | tr '\n' ' ' | sed 's/ $//' || true)

if [ -n "$existing_pids" ]; then
    echo "âš ï¸  Server already running on port $http_port"
    echo ""
    
    # Show all processes using this port
    for pid in $existing_pids; do
        process_info=$(ps -p "$pid" -o command= 2>/dev/null || echo "unknown process")
        echo "  PID $pid: $process_info"
    done
    echo ""
    
    # Ask user what to do
    read -r -p "Stop all processes on port $http_port and start a new server? [y/N] " response
    case "$response" in
        [yY][eE][sS]|[yY])
            # Stop all processes
            for pid in $existing_pids; do
                echo "Stopping process $pid..."
                kill "$pid" 2>/dev/null || true
            done
            
            # Wait for processes to terminate (max 5 seconds)
            sleep 1
            for i in {1..10}; do
                still_running=$(lsof -ti tcp:"$http_port" 2>/dev/null || true)
                if [ -z "$still_running" ]; then
                    echo "âœ… All processes stopped"
                    sleep 1  # Give port time to be released
                    break
                fi
                sleep 0.5
            done
            
            # Force kill any remaining processes
            still_running=$(lsof -ti tcp:"$http_port" 2>/dev/null || true)
            if [ -n "$still_running" ]; then
                echo "Some processes still running, forcing termination..."
                for pid in $still_running; do
                    kill -KILL "$pid" 2>/dev/null || true
                done
                sleep 1
            fi
            ;;
        *)
            echo "Cancelled. Existing server(s) will continue running."
            exit 0
            ;;
    esac
fi

# Add uv to PATH if it exists
if [ -d "$HOME/.local/bin" ]; then
    export PATH="$HOME/.local/bin:$PATH"
fi

# Activate virtual environment
if [ -d ".venv" ]; then
    # shellcheck source=/dev/null
    source .venv/bin/activate
else
    echo "âŒ Error: Virtual environment not found."
    echo "Run './setup' first to create the environment."
    exit 1
fi

# Create logs directory and handle log rotation (always, for dual logging support)
mkdir -p logs
log_file="logs/my-tracks.log"

# Rotate logs: keep last 5 files
if [ -f "$log_file" ]; then
    # Remove oldest log if we already have 5
    [ -f "logs/my-tracks.log.5" ] && rm -f "logs/my-tracks.log.5"
    
    # Shift logs: .4 -> .5, .3 -> .4, etc.
    for i in 4 3 2 1; do
        if [ -f "logs/my-tracks.log.$i" ]; then
            mv "logs/my-tracks.log.$i" "logs/my-tracks.log.$((i + 1))"
        fi
    done
    
    # Move current log to .1
    mv "$log_file" "logs/my-tracks.log.1"
fi

# Export Django logging configuration
export DJANGO_LOG_LEVEL="$log_level"

# Write runtime configuration file (avoids using env vars for ports)
runtime_config="config/.runtime-config.json"
cat > "$runtime_config" << EOF
{
  "http_port": $http_port,
  "mqtt_port": $mqtt_port
}
EOF

# Collect static files for whitenoise (required for ASGI static file serving)
echo "ðŸ“¦ Collecting static files..."
uv run python manage.py collectstatic --noinput --clear > /dev/null 2>&1

# Get all local IP addresses (non-loopback)
get_local_ips() {
    if command -v python3 &>/dev/null; then
        python3 -c "
import netifaces
ips = []
for iface in netifaces.interfaces():
    addrs = netifaces.ifaddresses(iface)
    for a in addrs.get(netifaces.AF_INET, []):
        ip = a.get('addr', '')
        has_broadcast = bool(a.get('broadcast'))
        if ip and not ip.startswith('127.') and has_broadcast:
            ips.append(ip)
for ip in sorted(set(ips)):
    print(ip)
" 2>/dev/null
    else
        # Fallback: try platform-specific commands
        ipconfig getifaddr en0 2>/dev/null || hostname -I 2>/dev/null | tr ' ' '\n' | grep -v '^$' || echo "unknown"
    fi
}

# Read IPs into an array
mapfile -t local_ips < <(get_local_ips)

# For port 0, we'll detect the actual port after daphne starts
display_http_port="$http_port"

# Function to get actual MQTT port from runtime config
get_actual_mqtt_port() {
    if [ -f "$runtime_config" ]; then
        # Try to read actual_mqtt_port from config, fall back to mqtt_port
        local actual
        actual=$(python3 -c "import json; c=json.load(open('$runtime_config')); print(c.get('actual_mqtt_port', c.get('mqtt_port', $mqtt_port)))" 2>/dev/null || echo "$mqtt_port")
        echo "$actual"
    else
        echo "$mqtt_port"
    fi
}

# Function to display server info (called after we know the actual port)
display_server_info() {
    local actual_http_port="$1"
    echo "ðŸš€ Starting Django server on http://0.0.0.0:$actual_http_port/"
    echo ""
    echo "ðŸ“¡ Network Access:"
    echo "   Local:   http://localhost:$actual_http_port/"
    if [ ${#local_ips[@]} -gt 0 ] && [ "${local_ips[0]}" != "unknown" ]; then
        for ip in "${local_ips[@]}"; do
            echo "   Network: http://$ip:$actual_http_port/"
        done
    else
        echo "   Network: Unable to determine IP address"
    fi
    echo ""
    if [ "$mqtt_port" -ge 0 ]; then
        local actual_mqtt
        actual_mqtt=$(get_actual_mqtt_port)
        echo "ðŸ“¶ MQTT Broker:"
        echo "   Port:    $actual_mqtt"
        if [ ${#local_ips[@]} -gt 0 ] && [ "${local_ips[0]}" != "unknown" ]; then
            for ip in "${local_ips[@]}"; do
                echo "   Address: $ip:$actual_mqtt"
            done
        fi
        echo ""
    fi
    echo "ðŸ“ Log level: $log_level"
}

if [ "$log_to_console" = true ]; then
    if [ "$http_port" = "0" ]; then
        echo "ðŸ” Requesting OS-allocated port..."
        echo ""
    fi
    
    # Start daphne with dual logging via process substitution
    # Note: Using >(tee) instead of | tee so that $! returns daphne's PID, not tee's
    daphne -b 0.0.0.0 -p "$http_port" --verbosity 0 config.asgi:application > >(tee -a "$log_file") 2>&1 &
    server_pid=$!
    
    # Wait for daphne to start and report the port
    sleep 1
    
    # Detect actual port from log file if port was 0
    if [ "$http_port" = "0" ]; then
        detected_http_port=$(grep -o 'Listening on TCP address [0-9.]*:\([0-9]*\)' "$log_file" 2>/dev/null | head -1 | grep -o '[0-9]*$')
        if [ -n "$detected_http_port" ]; then
            display_http_port="$detected_http_port"
        fi
    fi
    
    # Show server info after we know the actual port
    echo ""
    display_server_info "$display_http_port"
    echo "ðŸ“º Logging to: console + $log_file (dual mode)"
    echo ""
    echo "Press CTRL-C to stop the server"
    echo ""
    
    # Wait for the server process
    wait $server_pid 2>/dev/null || true
else
    if [ "$http_port" = "0" ]; then
        echo "ðŸ” Requesting OS-allocated port..."
    fi
    
    # Start daphne in background, capturing output to log
    daphne -b 0.0.0.0 -p "$http_port" --verbosity 0 config.asgi:application >> "$log_file" 2>&1 &
    server_pid=$!
    
    # Wait for daphne to start and report the port
    sleep 1
    
    # Detect actual port from log file if port was 0
    if [ "$http_port" = "0" ]; then
        detected_http_port=$(grep -o 'Listening on TCP address [0-9.]*:\([0-9]*\)' "$log_file" 2>/dev/null | head -1 | grep -o '[0-9]*$')
        if [ -n "$detected_http_port" ]; then
            display_http_port="$detected_http_port"
        fi
    fi
    
    display_server_info "$display_http_port"
    echo "ðŸ“„ Logging to: $log_file"
    echo "ðŸ’¡ Tip: Use --console flag to also see logs in terminal"
    echo ""
    echo "Press CTRL-C to stop the server"
    echo ""
    
    # Wait for the server process
    wait $server_pid 2>/dev/null || true
fi

# If we get here without the trap, ensure cleanup runs
# (This handles the case where wait returns normally)
trap - EXIT
