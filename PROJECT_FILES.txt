# Run this script to create the project structure:
# ./setup

#
# Then manually create the following files in their respective directories:
# 
# mytracks/__init__.py
# mytracks/settings.py
# mytracks/urls.py
# mytracks/wsgi.py
# mytracks/asgi.py
#
# tracker/__init__.py
# tracker/admin.py
# tracker/apps.py
# tracker/models.py
# tracker/serializers.py
# tracker/views.py
# tracker/urls.py
# tracker/migrations/__init__.py
#
# All file contents are provided below:

# ===== mytracks/__init__.py =====
"""Django project package initialization."""

# ===== mytracks/settings.py =====
"""
Django settings for mytracks project.

Generated for Django 5.0, using Python 3.12+.
For more information on this file, see
https://docs.djangoproject.com/en/5.0/topics/settings/

For the full list of settings and their values, see
https://docs.djangoproject.com/en/5.0/ref/settings/
"""

from pathlib import Path
from typing import List
from decouple import config

# Build paths inside the project like this: BASE_DIR / 'subdir'.
BASE_DIR: Path = Path(__file__).resolve().parent.parent


# Quick-start development settings - unsuitable for production
# See https://docs.djangoproject.com/en/5.0/howto/deployment/checklist/

# SECURITY WARNING: keep the secret key used in production secret!
SECRET_KEY: str = config('SECRET_KEY', default='django-insecure-change-me-in-production')

# SECURITY WARNING: don't run with debug turned on in production!
DEBUG: bool = config('DEBUG', default=True, cast=bool)

ALLOWED_HOSTS: List[str] = config(
    'ALLOWED_HOSTS',
    default='localhost,127.0.0.1',
    cast=lambda v: [s.strip() for s in v.split(',')]
)


# Application definition

INSTALLED_APPS: List[str] = [
    'django.contrib.admin',
    'django.contrib.auth',
    'django.contrib.contenttypes',
    'django.contrib.sessions',
    'django.contrib.messages',
    'django.contrib.staticfiles',
    'rest_framework',
    'tracker.apps.TrackerConfig',
]

MIDDLEWARE: List[str] = [
    'django.middleware.security.SecurityMiddleware',
    'django.contrib.sessions.middleware.SessionMiddleware',
    'django.middleware.common.CommonMiddleware',
    'django.middleware.csrf.CsrfViewMiddleware',
    'django.contrib.auth.middleware.AuthenticationMiddleware',
    'django.contrib.messages.middleware.MessageMiddleware',
    'django.middleware.clickjacking.XFrameOptionsMiddleware',
]

ROOT_URLCONF: str = 'mytracks.urls'

TEMPLATES: List[dict] = [
    {
        'BACKEND': 'django.template.backends.django.DjangoTemplates',
        'DIRS': [],
        'APP_DIRS': True,
        'OPTIONS': {
            'context_processors': [
                'django.template.context_processors.debug',
                'django.template.context_processors.request',
                'django.contrib.auth.context_processors.auth',
                'django.contrib.messages.context_processors.messages',
            ],
        },
    },
]

WSGI_APPLICATION: str = 'mytracks.wsgi.application'


# Database
# https://docs.djangoproject.com/en/5.0/ref/settings/#databases

DATABASES: dict = {
    'default': {
        'ENGINE': 'django.db.backends.sqlite3',
        'NAME': BASE_DIR / 'db.sqlite3',
    }
}


# Password validation
# https://docs.djangoproject.com/en/5.0/ref/settings/#auth-password-validators

AUTH_PASSWORD_VALIDATORS: List[dict] = [
    {
        'NAME': 'django.contrib.auth.password_validation.UserAttributeSimilarityValidator',
    },
    {
        'NAME': 'django.contrib.auth.password_validation.MinimumLengthValidator',
    },
    {
        'NAME': 'django.contrib.auth.password_validation.CommonPasswordValidator',
    },
    {
        'NAME': 'django.contrib.auth.password_validation.NumericPasswordValidator',
    },
]


# Internationalization
# https://docs.djangoproject.com/en/5.0/topics/i18n/

LANGUAGE_CODE: str = 'en-us'

TIME_ZONE: str = 'UTC'

USE_I18N: bool = True

USE_TZ: bool = True


# Static files (CSS, JavaScript, Images)
# https://docs.djangoproject.com/en/5.0/howto/static-files/

STATIC_URL: str = 'static/'

# Default primary key field type
# https://docs.djangoproject.com/en/5.0/ref/settings/#default-auto-field

DEFAULT_AUTO_FIELD: str = 'django.db.models.BigAutoField'


# REST Framework settings
REST_FRAMEWORK: dict = {
    'DEFAULT_RENDERER_CLASSES': [
        'rest_framework.renderers.JSONRenderer',
    ],
    'DEFAULT_PARSER_CLASSES': [
        'rest_framework.parsers.JSONParser',
    ],
    'DEFAULT_PAGINATION_CLASS': 'rest_framework.pagination.LimitOffsetPagination',
    'PAGE_SIZE': 100,
}

# CSRF exemption for OwnTracks endpoints (they use device authentication)
CSRF_TRUSTED_ORIGINS: List[str] = config(
    'CSRF_TRUSTED_ORIGINS',
    default='',
    cast=lambda v: [s.strip() for s in v.split(',') if s.strip()]
)

# ===== mytracks/urls.py =====
"""
URL configuration for mytracks project.

The `urlpatterns` list routes URLs to views. For more information please see:
    https://docs.djangoproject.com/en/5.0/topics/http/urls/
"""
from django.contrib import admin
from django.urls import path, include
from typing import List
from django.urls.resolvers import URLPattern, URLResolver

urlpatterns: List[URLPattern | URLResolver] = [
    path('admin/', admin.site.urls),
    path('api/', include('tracker.urls')),
]

# ===== mytracks/wsgi.py =====
"""
WSGI config for mytracks project.

It exposes the WSGI callable as a module-level variable named ``application``.

For more information on this file, see
https://docs.djangoproject.com/en/5.0/howto/deployment/wsgi/
"""

import os

from django.core.wsgi import get_wsgi_application

os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'mytracks.settings')

application = get_wsgi_application()

# ===== mytracks/asgi.py =====
"""
ASGI config for mytracks project.

It exposes the ASGI callable as a module-level variable named ``application``.

For more information on this file, see
https://docs.djangoproject.com/en/5.0/howto/deployment/asgi/
"""

import os

from django.core.asgi import get_asgi_application

os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'mytracks.settings')

application = get_asgi_application()

# ===== tracker/__init__.py =====
"""My Tracks location tracking app."""

# ===== tracker/apps.py =====
"""App configuration for tracker application."""
from django.apps import AppConfig


class TrackerConfig(AppConfig):
    """Configuration for the tracker app."""
    
    default_auto_field: str = 'django.db.models.BigAutoField'
    name: str = 'tracker'
    verbose_name: str = 'My Tracks'

# ===== tracker/models.py =====
"""
Database models for OwnTracks location tracking.

This module defines the data models for storing device information
and location data from OwnTracks clients.
"""
from django.db import models
from django.utils import timezone
from typing import Optional
from dataclasses import dataclass


class Device(models.Model):
    """
    Represents a device (phone/tablet) running OwnTracks.
    
    Each device is uniquely identified by its device_id, which is sent
    by the OwnTracks client in location updates.
    """
    
    device_id = models.CharField(
        max_length=100,
        unique=True,
        db_index=True,
        help_text="Unique identifier for the device (from OwnTracks 'tid' field)"
    )
    name = models.CharField(
        max_length=200,
        blank=True,
        help_text="Friendly name for the device"
    )
    created_at = models.DateTimeField(
        auto_now_add=True,
        help_text="When this device was first registered"
    )
    last_seen = models.DateTimeField(
        auto_now=True,
        help_text="Last time location data was received from this device"
    )
    
    class Meta:
        ordering = ['-last_seen']
        verbose_name = 'Device'
        verbose_name_plural = 'Devices'
    
    def __str__(self) -> str:
        """Return string representation of the device."""
        if self.name:
            return f"{self.name} ({self.device_id})"
        return self.device_id


class Location(models.Model):
    """
    Represents a single location data point from OwnTracks.
    
    Stores comprehensive location information including coordinates,
    accuracy, altitude, velocity, battery level, and connection type.
    """
    
    device = models.ForeignKey(
        Device,
        on_delete=models.CASCADE,
        related_name='locations',
        help_text="The device that reported this location"
    )
    
    # Core location data (required fields)
    latitude = models.DecimalField(
        max_digits=9,
        decimal_places=6,
        help_text="Latitude in decimal degrees (-90 to +90)"
    )
    longitude = models.DecimalField(
        max_digits=9,
        decimal_places=6,
        help_text="Longitude in decimal degrees (-180 to +180)"
    )
    timestamp = models.DateTimeField(
        db_index=True,
        help_text="Unix timestamp when location was recorded (from 'tst' field)"
    )
    
    # Optional location metadata
    accuracy = models.IntegerField(
        null=True,
        blank=True,
        help_text="Accuracy of location in meters (from 'acc' field)"
    )
    altitude = models.IntegerField(
        null=True,
        blank=True,
        help_text="Altitude above sea level in meters (from 'alt' field)"
    )
    velocity = models.IntegerField(
        null=True,
        blank=True,
        help_text="Velocity/speed in km/h (from 'vel' field)"
    )
    battery_level = models.IntegerField(
        null=True,
        blank=True,
        help_text="Battery percentage 0-100 (from 'batt' field)"
    )
    
    # Connection type: w=WiFi, o=Offline, m=Mobile
    connection_type = models.CharField(
        max_length=1,
        blank=True,
        help_text="Connection type (from 'conn' field): w=WiFi, o=Offline, m=Mobile"
    )
    
    # Tracking metadata
    received_at = models.DateTimeField(
        auto_now_add=True,
        help_text="When the server received this location data"
    )
    
    class Meta:
        ordering = ['-timestamp']
        verbose_name = 'Location'
        verbose_name_plural = 'Locations'
        indexes = [
            models.Index(fields=['device', '-timestamp']),
            models.Index(fields=['-timestamp']),
        ]
    
    def __str__(self) -> str:
        """Return string representation of the location."""
        return f"{self.device.device_id} @ ({self.latitude}, {self.longitude}) on {self.timestamp}"


# ===== tracker/serializers.py =====
"""
Serializers for OwnTracks location tracking API.

This module provides DRF serializers for converting between
OwnTracks JSON payloads and Django model instances.
"""
from rest_framework import serializers
from typing import Dict, Any
from datetime import datetime
from .models import Device, Location


class DeviceSerializer(serializers.ModelSerializer):
    """Serializer for Device model."""
    
    location_count = serializers.SerializerMethodField()
    
    class Meta:
        model = Device
        fields = ['id', 'device_id', 'name', 'created_at', 'last_seen', 'location_count']
        read_only_fields = ['id', 'created_at', 'last_seen']
    
    def get_location_count(self, obj: Device) -> int:
        """Get the total number of locations for this device."""
        return obj.locations.count()


class LocationSerializer(serializers.ModelSerializer):
    """
    Serializer for Location model.
    
    Handles both OwnTracks format (for incoming data) and
    standard format (for API responses).
    """
    
    device_id = serializers.CharField(write_only=True, required=False)
    tid = serializers.CharField(write_only=True, required=False, help_text="OwnTracks tracker ID")
    lat = serializers.DecimalField(
        max_digits=9,
        decimal_places=6,
        write_only=True,
        help_text="OwnTracks latitude field"
    )
    lon = serializers.DecimalField(
        max_digits=9,
        decimal_places=6,
        write_only=True,
        help_text="OwnTracks longitude field"
    )
    tst = serializers.IntegerField(
        write_only=True,
        help_text="OwnTracks Unix timestamp"
    )
    acc = serializers.IntegerField(
        write_only=True,
        required=False,
        help_text="OwnTracks accuracy"
    )
    alt = serializers.IntegerField(
        write_only=True,
        required=False,
        help_text="OwnTracks altitude"
    )
    vel = serializers.IntegerField(
        write_only=True,
        required=False,
        help_text="OwnTracks velocity"
    )
    batt = serializers.IntegerField(
        write_only=True,
        required=False,
        help_text="OwnTracks battery level"
    )
    conn = serializers.CharField(
        write_only=True,
        required=False,
        max_length=1,
        help_text="OwnTracks connection type"
    )
    _type = serializers.CharField(
        write_only=True,
        required=False,
        help_text="OwnTracks message type"
    )
    
    class Meta:
        model = Location
        fields = [
            'id', 'device', 'device_id', 'tid',
            'latitude', 'longitude', 'timestamp',
            'lat', 'lon', 'tst',
            'accuracy', 'altitude', 'velocity', 'battery_level', 'connection_type',
            'acc', 'alt', 'vel', 'batt', 'conn', '_type',
            'received_at'
        ]
        read_only_fields = ['id', 'device', 'received_at']
    
    def validate(self, attrs: Dict[str, Any]) -> Dict[str, Any]:
        """
        Validate and transform OwnTracks format to internal format.
        
        Converts OwnTracks field names (lat, lon, tst, etc.) to
        Django model field names (latitude, longitude, timestamp, etc.).
        
        Args:
            attrs: Input attributes from request
            
        Returns:
            Validated and transformed attributes
            
        Raises:
            serializers.ValidationError: If required fields are missing or invalid
        """
        # Device identification
        device_id = attrs.get('device_id') or attrs.get('tid')
        if not device_id:
            raise serializers.ValidationError(
                "Expected 'device_id' or 'tid' field for device identification, got neither"
            )
        
        # Get or create device
        device, _ = Device.objects.get_or_create(
            device_id=device_id,
            defaults={'name': f'Device {device_id}'}
        )
        
        # Map OwnTracks fields to model fields
        transformed = {
            'device': device,
            'latitude': attrs.get('lat'),
            'longitude': attrs.get('lon'),
            'timestamp': datetime.fromtimestamp(attrs.get('tst')),
            'accuracy': attrs.get('acc'),
            'altitude': attrs.get('alt'),
            'velocity': attrs.get('vel'),
            'battery_level': attrs.get('batt'),
            'connection_type': attrs.get('conn', ''),
        }
        
        # Validate latitude range
        if not -90 <= transformed['latitude'] <= 90:
            raise serializers.ValidationError(
                f"Expected latitude between -90 and +90 degrees, got {transformed['latitude']}"
            )
        
        # Validate longitude range
        if not -180 <= transformed['longitude'] <= 180:
            raise serializers.ValidationError(
                f"Expected longitude between -180 and +180 degrees, got {transformed['longitude']}"
            )
        
        # Validate battery level if provided
        if transformed['battery_level'] is not None:
            if not 0 <= transformed['battery_level'] <= 100:
                raise serializers.ValidationError(
                    f"Expected battery level between 0 and 100, got {transformed['battery_level']}"
                )
        
        return transformed


# ===== tracker/views.py =====
"""
API views for OwnTracks location tracking.

This module provides REST API endpoints for receiving location data
from OwnTracks clients and querying stored location history.
"""
from rest_framework import viewsets, status
from rest_framework.decorators import action
from rest_framework.request import Request
from rest_framework.response import Response
from django.utils.decorators import method_decorator
from django.views.decorators.csrf import csrf_exempt
from typing import Any
from datetime import datetime
from .models import Device, Location
from .serializers import DeviceSerializer, LocationSerializer


@method_decorator(csrf_exempt, name='dispatch')
class LocationViewSet(viewsets.ModelViewSet):
    """
    ViewSet for managing location data.
    
    Provides endpoints for:
    - POST: Receive location data from OwnTracks clients
    - GET: Query location history
    - Filter by device, date range, etc.
    """
    
    queryset = Location.objects.all()
    serializer_class = LocationSerializer
    
    def create(self, request: Request, *args: Any, **kwargs: Any) -> Response:
        """
        Handle incoming location data from OwnTracks client.
        
        Accepts OwnTracks JSON format and creates a new location record.
        
        Args:
            request: HTTP request with OwnTracks JSON payload
            
        Returns:
            Response with 201 Created status on success
            
        Raises:
            ValidationError: If payload is invalid
        """
        serializer = self.get_serializer(data=request.data)
        serializer.is_valid(raise_exception=True)
        self.perform_create(serializer)
        
        return Response(
            {'status': 'ok', 'message': 'Location received'},
            status=status.HTTP_201_CREATED
        )
    
    def list(self, request: Request, *args: Any, **kwargs: Any) -> Response:
        """
        List location history with optional filtering.
        
        Query parameters:
        - device: Filter by device ID
        - start_date: ISO 8601 datetime (e.g., 2024-01-01T00:00:00Z)
        - end_date: ISO 8601 datetime
        - limit: Maximum number of results
        
        Args:
            request: HTTP request with query parameters
            
        Returns:
            Paginated list of location records
        """
        queryset = self.get_queryset()
        
        # Filter by device
        device_id = request.query_params.get('device')
        if device_id:
            try:
                device = Device.objects.get(device_id=device_id)
                queryset = queryset.filter(device=device)
            except Device.DoesNotExist:
                return Response(
                    {
                        'error': f"Expected valid device ID, got '{device_id}' which does not exist"
                    },
                    status=status.HTTP_404_NOT_FOUND
                )
        
        # Filter by date range
        start_date = request.query_params.get('start_date')
        if start_date:
            try:
                start_dt = datetime.fromisoformat(start_date.replace('Z', '+00:00'))
                queryset = queryset.filter(timestamp__gte=start_dt)
            except ValueError as e:
                return Response(
                    {
                        'error': f"Expected ISO 8601 datetime for start_date, got invalid format: {e}"
                    },
                    status=status.HTTP_400_BAD_REQUEST
                )
        
        end_date = request.query_params.get('end_date')
        if end_date:
            try:
                end_dt = datetime.fromisoformat(end_date.replace('Z', '+00:00'))
                queryset = queryset.filter(timestamp__lte=end_dt)
            except ValueError as e:
                return Response(
                    {
                        'error': f"Expected ISO 8601 datetime for end_date, got invalid format: {e}"
                    },
                    status=status.HTTP_400_BAD_REQUEST
                )
        
        page = self.paginate_queryset(queryset)
        if page is not None:
            serializer = self.get_serializer(page, many=True)
            return self.get_paginated_response(serializer.data)
        
        serializer = self.get_serializer(queryset, many=True)
        return Response(serializer.data)


class DeviceViewSet(viewsets.ReadOnlyModelViewSet):
    """
    ViewSet for managing devices.
    
    Provides read-only endpoints for:
    - GET /devices/: List all devices
    - GET /devices/{id}/: Get device details
    - GET /devices/{id}/locations/: Get locations for specific device
    """
    
    queryset = Device.objects.all()
    serializer_class = DeviceSerializer
    lookup_field = 'device_id'
    
    @action(detail=True, methods=['get'])
    def locations(self, request: Request, device_id: str = None) -> Response:
        """
        Get all locations for a specific device.
        
        Args:
            request: HTTP request
            device_id: Device identifier
            
        Returns:
            Paginated list of locations for the device
        """
        device = self.get_object()
        locations = device.locations.all()
        
        page = self.paginate_queryset(locations)
        if page is not None:
            serializer = LocationSerializer(page, many=True)
            return self.get_paginated_response(serializer.data)
        
        serializer = LocationSerializer(locations, many=True)
        return Response(serializer.data)


# ===== tracker/urls.py =====
"""URL routing for tracker app."""
from django.urls import path, include
from rest_framework.routers import DefaultRouter
from typing import List
from django.urls.resolvers import URLPattern, URLResolver
from .views import LocationViewSet, DeviceViewSet

router = DefaultRouter()
router.register(r'locations', LocationViewSet, basename='location')
router.register(r'devices', DeviceViewSet, basename='device')

urlpatterns: List[URLPattern | URLResolver] = [
    path('', include(router.urls)),
]

# ===== tracker/admin.py =====
"""Django admin configuration for tracker app."""
from django.contrib import admin
from typing import List, Tuple
from .models import Device, Location


@admin.register(Device)
class DeviceAdmin(admin.ModelAdmin):
    """Admin interface for Device model."""
    
    list_display: Tuple[str, ...] = ('device_id', 'name', 'last_seen', 'created_at')
    list_filter: Tuple[str, ...] = ('created_at', 'last_seen')
    search_fields: Tuple[str, ...] = ('device_id', 'name')
    readonly_fields: Tuple[str, ...] = ('created_at', 'last_seen')


@admin.register(Location)
class LocationAdmin(admin.ModelAdmin):
    """Admin interface for Location model."""
    
    list_display: Tuple[str, ...] = (
        'device',
        'latitude',
        'longitude',
        'timestamp',
        'accuracy',
        'battery_level',
        'received_at'
    )
    list_filter: Tuple[str, ...] = ('device', 'timestamp', 'connection_type')
    search_fields: Tuple[str, ...] = ('device__device_id', 'device__name')
    readonly_fields: Tuple[str, ...] = ('received_at',)
    date_hierarchy: str = 'timestamp'

# ===== tracker/migrations/__init__.py =====
"""Migrations package for tracker app."""
